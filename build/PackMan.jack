class PackMan
{
    field int lastKey, direction, nextDirection, location, lastLocation, gridIndex;
    field bool updateSprite;
    field AnimationManager am;
    field Vector2 position;

    constructor PackMan new(int x, int y)
    {
        var int i, j;
        let i = 0;
        let j = 0;

        let lastKey = 0;
        let direction = 0;
        let nextDirection = 0;
        let updateSprite = true;
        let am = AnimationManager.new(4);
        let position = Vector2.new(x, y);
        let location = ScreenManager.getLocation(x, y);
        let gridIndex = y * 32 + x;

        while (i < 16)
        {
            if (j = 32)
            {
                let i = i + 1;
                let j = 0;
            }

            if (Game.grid(i * 32 + j) = 4)
            {
                let location = ScreenManager.getLocation(j, i);
                let gridIndex = i * 32 + j;
                do position.setX(j);
                do position.setY(i);
            }

            let j = j + 1;
        }

        do loadAnimations();

        return this;
    }

    method void loadAnimations()
    {
        var Animation animation;

        let animation = Animation.new(2);
        do animation.add(PackManAsset.mouthOpenLeft());
        do animation.add(PackManAsset.mouthClosed());
        do am.add(animation);

        let animation = Animation.new(2);
        do animation.add(PackManAsset.mouthOpenRight());
        do animation.add(PackManAsset.mouthClosed());
        do am.add(animation);

        let animation = Animation.new(2);
        do animation.add(PackManAsset.mouthOpenUp());
        do animation.add(PackManAsset.mouthClosed());
        do am.add(animation);

        let animation = Animation.new(2);
        do animation.add(PackManAsset.mouthOpenDown());
        do animation.add(PackManAsset.mouthClosed());
        do am.add(animation);

        do am.set(Constants.packManRight());

        return;
    }

    method Vector2 getPosition()
    {
        return position;
    }

    method void increaseScore(int index)
    {
        do Game.setGrid(index, 0);
        do Game.increaseScore(index);

        return;
    }

    // promjeni da su prva 3 prazno, dot i ability
    method bool checkCollisionUp()    { if (Game.grid(gridIndex - 32) < 5) {return true;} else {return false;}}
    method bool checkCollisionDown()  { if (Game.grid(gridIndex + 32) < 5) {return true;} else {return false;}}
    method bool checkCollisionLeft()  { if (Game.grid(gridIndex - 1) < 5)  {return true;} else {return false;}}
    method bool checkCollisionRight() { if (Game.grid(gridIndex + 1) < 5)  {return true;} else {return false;}}

    method void moveInit()
    {
        let updateSprite = true;
        let lastLocation = location;

        return;
    }

    method void moveStop()
    {
        let direction = 0;
        //let updateSprite = false;

        return;
    }

    method void moveRight()
    {
        if (Game.grid(gridIndex) = 3)
        {
            do ScreenManager.clearBlock(location);
            let location = location - 31;
            let gridIndex = gridIndex - 31;
            //dodati position logiku
        }

        if (checkCollisionRight())
        {
            if (Game.grid(gridIndex + 1) = 1) 
                {do increaseScore(gridIndex + 1);}

            do moveInit();
            let location = location + 1;
            let gridIndex = gridIndex + 1;
            do position.incX();
            do am.set(Constants.packManRight());
        }
        else { do moveStop(); }

        return;
    }

    method void moveLeft()
    {
        if (Game.grid(gridIndex) = 3)
        {
            do ScreenManager.clearBlock(location);
            let location = location + 31;
            let gridIndex = gridIndex + 31;
            //dodaj position logiku
        }

        if (checkCollisionLeft())
        {
            if (Game.grid(gridIndex - 1) = 1) 
                {do increaseScore(gridIndex - 1);}

            do moveInit();
            let location = location - 1;
            let gridIndex = gridIndex - 1;
            do position.decX();
            do am.set(Constants.packManLeft());
        }
        else { do moveStop(); }

        return;
    }

    method void moveUp()
    {
        if (checkCollisionUp())
        {
            if (Game.grid(gridIndex - 32) = 1) 
                {do increaseScore(gridIndex - 32);}
            do moveInit();
            let location = location - 512;
            let gridIndex = gridIndex - 32;
            do position.decY();
            do am.set(Constants.packManUp());
        }
        else { do moveStop(); }
        
        return;
    }

    method void moveDown()
    {
        if (checkCollisionDown())
        {
            if (Game.grid(gridIndex + 32) = 1) 
                {do increaseScore(gridIndex + 32);}
            do moveInit();
            let location = location + 512;
            let gridIndex = gridIndex + 32;
            do position.incY();
            do am.set(Constants.packManDown());
        }
        else { do moveStop(); }
        
        return;
    }

    method void input()
    {
        var int kybrd;
        
        let kybrd = Keyboard.keyPressed();
        //do Logger.logInt(kybrd); 

        if ((kybrd = 130) & ~(lastKey = kybrd))
        {
            let nextDirection = -1;
            let lastKey = kybrd;
            do Game.setSeed(); 
        } 
        else {if (kybrd = 132 & ~(lastKey = kybrd))
        {
            let nextDirection = 1;
            let lastKey = kybrd;
            do Game.setSeed();
        }
        else {if ((kybrd = 131) & ~(lastKey = kybrd))
        {
            let nextDirection = -2;
            let lastKey = kybrd;
            do Game.setSeed();
        } 
        else {if (kybrd = 133 & ~(lastKey = kybrd))
        {
            let nextDirection = 2;
            let lastKey = kybrd;
            do Game.setSeed();
        }
        else {if (kybrd = 0 & ~(lastKey = kybrd))
        {
            let lastKey = kybrd;
        }}}}}
          
        return;
    }

    method void move()
    {
        if (Game.grid(gridIndex) = 2)
            { do Game.setFrightened(); }

        if (~(direction = nextDirection))
        {
            if ((nextDirection = 1  & checkCollisionRight()) | 
                (nextDirection = -1 & checkCollisionLeft())  |
                (nextDirection = 2  & checkCollisionDown())  |
                (nextDirection = -2 & checkCollisionUp()))
            {
                let direction = nextDirection;
            }
        }
        
        if (direction = 1)
            { do moveRight(); }
        else {if (direction = -1)
            { do moveLeft(); }
        else {if (direction = 2)
            { do moveDown(); }
        else {if (direction = -2)
            { do moveUp(); }}}}

        return;
    }

    method void draw()
    {
        if (lastLocation > Constants.getScreen() & ~(location = lastLocation))
        {
            //do Logger.logInt(lastLocation);
            do ScreenManager.clearBlock(lastLocation);
        }

        if (updateSprite)
        {
            do am.drawNext(location);
        } 

        return; 
    }
}
